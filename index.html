<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>URL Cleaner</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>URL Cleaner</h1>

    <!-- Input -->
    <div class="card">
      <div class="card-header">Input</div>
      <textarea
        id="input"
        placeholder="Paste your text with URL here..."
        rows="3"
      ></textarea>
    </div>

    <!-- Editor -->
    <div id="editor" class="hidden">
      <div class="section-header">Editor</div>
      <div class="card">
      <!-- Prefix -->
      <div class="editor-section">
        <label class="editor-label">Prefix</label>
        <input type="text" id="prefix" class="editor-input">
      </div>

      <!-- URL Base -->
      <div class="editor-section">
        <label class="editor-label">URL Base</label>
        <input type="text" id="urlBase" class="editor-input url-base">
      </div>

      <!-- Parameters -->
      <div class="params-section">
        <label class="params-label">Parameters</label>
        <div id="params"></div>
      </div>

      <!-- Suffix -->
      <div class="editor-section">
        <label class="editor-label">Suffix</label>
        <input type="text" id="suffix" class="editor-input">
      </div>
      </div>
    </div>

    <!-- Cleaned Result -->
    <div id="resultSection" class="card hidden">
      <div class="card-header">Cleaned Result</div>
      <div class="result-container" onclick="copyResult()">
        <div id="result"></div>
      </div>
    </div>
  </div>

  <footer style="text-align: center; margin-top: 40px; padding-bottom: 20px; color: #666; font-size: 14px;">
    <a href="https://github.com/PkuCuipy/url-cleaner/" target="_blank" style="color: #0066cc; text-decoration: none;">GitHub Repo</a>
    · © 2025 PkuCuipy
  </footer>

  <script src="rules.js"></script>
  <script>
    let state = {
      prefix: '',
      url: {
        base: '',
        params: [],
        hash: ''
      },
      suffix: ''
    };

    // Extract URL from text
    function extractURL(text) {
      const urlRegex = /(https?:\/\/[^\s]+)/;
      const match = text.match(urlRegex);

      if (!match) return null;

      const url = match[0];
      const urlStart = match.index;
      const urlEnd = urlStart + url.length;

      return {
        prefix: text.substring(0, urlStart),
        url: url,
        suffix: text.substring(urlEnd)
      };
    }

    // Parse URL into components
    function parseURL(urlString) {
      const url = new URL(urlString);
      const params = [];

      url.searchParams.forEach((value, key) => {
        params.push({ key, value, enabled: true });
      });

      return {
        base: url.origin + url.pathname,
        params: params,
        hash: url.hash
      };
    }

    // Match domain rules
    function matchRule(urlBase) {
      for (const [domain, requiredParams] of Object.entries(URL_RULES)) {
        if (urlBase.includes(domain)) {
          return requiredParams;
        }
      }
      return null;
    }

    // Apply rules to parameters
    function applyRules(params, urlBase) {
      const rule = matchRule(urlBase);

      if (rule === null) {
        // No rule: keep all parameters
        params.forEach(p => p.enabled = true);
      } else if (rule.length === 0) {
        // Empty rule: remove all parameters
        params.forEach(p => p.enabled = false);
      } else {
        // Apply specific rule
        params.forEach(p => {
          p.enabled = rule.includes(p.key);
        });
      }
    }

    // Build clean URL
    function buildURL() {
      const enabledParams = state.url.params.filter(p => p.enabled);
      const queryString = enabledParams
        .map(p => `${p.key}=${p.value}`)
        .join('&');

      let cleanURL = state.url.base;
      if (queryString) {
        cleanURL += '?' + queryString;
      }
      if (state.url.hash) {
        cleanURL += state.url.hash;
      }

      // Ensure proper spacing
      let prefix = state.prefix;
      let suffix = state.suffix;

      if (prefix && !prefix.endsWith(' ') && !prefix.endsWith('\n')) {
        prefix += ' ';
      }
      if (suffix && !suffix.startsWith(' ') && !suffix.startsWith('\n')) {
        suffix = ' ' + suffix;
      }

      return prefix + cleanURL + suffix;
    }

    // Render the editor
    function render() {
      document.getElementById('prefix').value = state.prefix;
      document.getElementById('urlBase').value = state.url.base + state.url.hash;
      document.getElementById('suffix').value = state.suffix;

      // Render parameters
      const paramsContainer = document.getElementById('params');
      paramsContainer.innerHTML = '';

      if (state.url.params.length === 0) {
        paramsContainer.innerHTML = '<div style="color: #999; font-size: 13px; padding: 12px;">No parameters</div>';
      } else {
        state.url.params.forEach((param, index) => {
          const div = document.createElement('div');
          div.className = 'param-item' + (param.enabled ? '' : ' disabled');
          div.onclick = () => toggleParam(index);

          div.innerHTML = `
            <input type="checkbox"
                   class="param-checkbox"
                   ${param.enabled ? 'checked' : ''}
                   onclick="event.stopPropagation(); toggleParam(${index})">
            <div class="param-content">
              <span class="param-key">${param.key}</span> = <span class="param-value">${param.value}</span>
            </div>
          `;

          paramsContainer.appendChild(div);
        });
      }

      // Update result
      const resultText = buildURL();
      document.getElementById('result').textContent = resultText;
    }

    // Toggle parameter
    function toggleParam(index) {
      state.url.params[index].enabled = !state.url.params[index].enabled;
      render();
    }

    // Handle input
    document.getElementById('input').addEventListener('input', function(e) {
      const text = e.target.value.trim();
      if (!text) return;

      const extracted = extractURL(text);
      if (!extracted) {
        alert('No URL found in the text');
        this.value = '';
        return;
      }

      const parsed = parseURL(extracted.url);
      applyRules(parsed.params, parsed.base);
      state.prefix = extracted.prefix;
      state.url = parsed;
      state.suffix = extracted.suffix;

      document.getElementById('editor').classList.remove('hidden');
      document.getElementById('resultSection').classList.remove('hidden');
      e.target.value = '';
      render();
    });

    // Handle editor input changes
    document.getElementById('prefix').addEventListener('input', function(e) {
      state.prefix = e.target.value;
      render();
    });

    document.getElementById('urlBase').addEventListener('input', function(e) {
      // Update URL base and hash
      const value = e.target.value;
      const hashIndex = value.indexOf('#');

      if (hashIndex !== -1) {
        state.url.base = value.substring(0, hashIndex);
        state.url.hash = value.substring(hashIndex);
      } else {
        state.url.base = value;
        state.url.hash = '';
      }

      render();
    });

    document.getElementById('suffix').addEventListener('input', function(e) {
      state.suffix = e.target.value;
      render();
    });

    // Copy result to clipboard
    function copyResult() {
      const result = buildURL();
      navigator.clipboard.writeText(result).then(() => {
        showToast('Copied to clipboard!');
      });
    }

    // Show toast notification
    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => {
        toast.remove();
      }, 2000);
    }
  </script>
</body>
</html>
